import{_ as c}from"./ValaxyMain.vue_vue_type_style_index_0_lang-BXnQbuOK.js";import{a as k,p as r,o as u,c as p,w as i,f as _,r as a,h as l,i as s}from"./app-B6fmPr7f.js";import"./YunFooter.vue_vue_type_script_setup_true_lang-BIdfHctK.js";import"./YunCard.vue_vue_type_script_setup_true_lang-BhC0baya.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-dsHSdnx4.js";import"./index-C7yU5XnD.js";const g=l("h1",{id:"基础",tabindex:"-1"},[s("基础 "),l("a",{class:"header-anchor",href:"#基础","aria-label":'Permalink to "基础"'},"​")],-1),m=l("h2",{id:"面向对象-oop-的特性",tabindex:"-1"},[s("面向对象(OOP)的特性 "),l("a",{class:"header-anchor",href:"#面向对象-oop-的特性","aria-label":'Permalink to "面向对象(OOP)的特性"'},"​")],-1),E=l("ul",null,[l("li",null,"封装 把客观事务封装成抽象的类且可以控制类中数据的访问权限，拥有属性与方法，类和结构体就是封装的体现。"),l("li",null,"继承 子类继承父类的公有属性和函数。"),l("li",null,"多态 分为静态多态和动态多态，静态多态体现为类中函数的重载，在编译时期完成；动态多态体现为可以用父类的指针或引用指向子类对象，程序运行时会根据子类的实际类型调用其对应的方法。通过虚指针实现，含义虚函数的类会有一张虚表(编译时生成存放虚函数的入口地址，该类的实例化对象共用一张虚表)，并且在实例化的时候会生成一个虚指针(保存虚表的地址)，因此通过这个虚指针父类可以找到子类中的虚函数。")],-1),f=l("h2",{id:"虚函数",tabindex:"-1"},[s("虚函数 "),l("a",{class:"header-anchor",href:"#虚函数","aria-label":'Permalink to "虚函数"'},"​")],-1),y=l("p",null,"类中使用 virtual 修饰的函数，其实现可以留给子类实现，类似 Java 中的抽象方法但有不同，子类可以不重写父类的虚函数。定义虚函数的作用就是为了让子类可以重写从而使得编译器能够使用动态绑定来达到多态。含有虚函数的类其析构函数必须定义为虚函数，原因见下文。注意：普通函数、静态函数、构造函数(因为虚指针是调用完构造方法后生成的)不能是虚函数。",-1),b=l("h2",{id:"虚指针",tabindex:"-1"},[s("虚指针 "),l("a",{class:"header-anchor",href:"#虚指针","aria-label":'Permalink to "虚指针"'},"​")],-1),v=l("p",null,"含有虚函数的类在实例化时会生成一个虚指针，该指针指向虚表。",-1),F=l("h2",{id:"纯虚函数",tabindex:"-1"},[s("纯虚函数 "),l("a",{class:"header-anchor",href:"#纯虚函数","aria-label":'Permalink to "纯虚函数"'},"​")],-1),A=l("p",null,[s("不能提供实现，方法的实现必须需要在子类中完成，含有纯虚函数的类叫做抽象类，不能被实例化，其子类必须实现其纯虚函数才能实例化。这个纯虚函数类似接口。与JAVA中的定义类似。例如："),l("code",null,"virtual int test()=0;")],-1),C=l("h2",{id:"内联函数-inline",tabindex:"-1"},[s("内联函数 "),l("code",null,"inline"),s(),l("a",{class:"header-anchor",href:"#内联函数-inline","aria-label":'Permalink to "内联函数 `inline`"'},"​")],-1),x=l("p",null,"主要目的是为了减少函数调用的开销。即将定义为内联函数的函数体代码复制到所有调用该函数的地方，有点类似宏定义，但是比宏定义多了类型检查，也是在编译时期执行。省去了参数压栈、栈帧开辟与回收，返回结果生成临时副本等提高了程序运行速度。在类中定义的函数(虚函数除外)都会隐式变成内联函数，但实际会不会执行代码展开还是由编译器决定，一般比较复杂的比如含义循环、递归等复杂的语句的函数编译器不会将其当成内联函数处理(声明了也没用)，也与函数的调用频率有关。一般用于简单的函数。缺点是会导致代码膨胀。",-1),P=l("h2",{id:"析构函数",tabindex:"-1"},[s("析构函数 "),l("a",{class:"header-anchor",href:"#析构函数","aria-label":'Permalink to "析构函数"'},"​")],-1),D=l("p",null,"类中用于正确释放其资源的函数，对象生命周期结束时编译器会自动调用且一个类中只能定义一个析构函数并且不能有参数，不显式声明会有默认的一个。虚析构函数可以是内联函数，但是在表现出多态的时候不可以是内联的，因为编译器需要在编译阶段确定调用的析构函数具体是哪个类的，只有在编译器具有实际的对象而不是对象的指针或引用时才会发生。例如：",-1),B=l("div",{style:{"max-height":"300px"},class:"language-C++ vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"C++"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"class"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," A"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"{")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    public:")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"        int*"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," a;")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    public:")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"        //构造函数")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"        A"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"int*"),l("span",{style:{"--shiki-light":"#E36209","--shiki-dark":"#FFAB70"}}," a_"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"):"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"a"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(a_){}")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"        //析构函数")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"        ~A"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(){")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"            delete"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," a;")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            a"),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"nullptr"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},";")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        }")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"};")])])]),l("button",{class:"collapse"})],-1),T=l("h2",{id:"拷贝构造函数-浅拷贝",tabindex:"-1"},[s("拷贝构造函数(浅拷贝) "),l("a",{class:"header-anchor",href:"#拷贝构造函数-浅拷贝","aria-label":'Permalink to "拷贝构造函数(浅拷贝)"'},"​")],-1),j=l("p",null,"可以看成通过一个已有类实例来初始化一个新的类实例，新类实例的属性值与被拷贝的类一样，个人认为是C++中都是值传递，比如说给一个参数是对象类型的函数传参的时候首先会先产生一个临时变量temp(即参数变量)，然后通过拷贝构造函数用实参来初始化这个相同类型的临时变量temp，拷贝完后析构掉这样临时变量temp。一般会在用类的一个的实例去初始化另一个类的实例、传递类类型的形参、返回类类型的返回值的情况下会使用到拷贝构造函数。没有显式声明则编译器会默认生成一个(不会处理静态成员变量)。含有指针类型的成员变量或动态分配内存的类必须显式声明一个拷贝构造函数。",-1),w=l("h2",{id:"const修饰符",tabindex:"-1"},[l("code",null,"const"),s("修饰符 "),l("a",{class:"header-anchor",href:"#const修饰符","aria-label":'Permalink to "`const`修饰符"'},"​")],-1),$=l("p",null,"可以修饰变量、指针、引用、成员函数。",-1),q=l("ul",null,[l("li",null,[l("p",null,"修饰变量 表示该变量不能再被重新赋值，即是个常量。")]),l("li",null,[l("p",null,"修饰指针"),l("ol",null,[l("li",null,[l("code",null,"const int* ptr = &a;"),s("表示一个常量指针，即指针指向的是一个常量，指针指向可以改变但改变后必须还是指向一个常量。(可以这么来理解，const右边修饰指针)")]),l("li",null,[l("code",null,"int* const ptr = &a;"),s("表示一个指针常量，即指针的指向不可以发生改变，但指向的对象的内容可以改变。("),l("code",null,"const"),s("右边修饰一个变量)")])])]),l("li",null,[l("p",null,"修饰引用"),l("ul",null,[l("li",null,[l("code",null,"const int& ref = &a;"),s("表示一个常量引用，即这个引用的值不能被修改，不存在引用常量这种，因为引用的实现是一个指针常量，在初始化之后就不能重新赋值了。")])])]),l("li",null,[l("p",null,"修饰成员函数"),l("ul",null,[l("li",null,[s("表示保证不会在此成员函数中修改成员变量的值(因为"),l("code",null,"this"),s("被修饰为了"),l("code",null,"const className* const this"),s("，即既不能对"),l("code",null,"this"),s("赋值也不能改变"),l("code",null,"this"),s("指向对象的内容)，"),l("code",null,"const"),s(" 修饰的函数会被重载，但是只能被 "),l("code",null,"const"),s(" 修饰的类的实例调用。例如：")])]),l("div",{style:{"max-height":"300px"},class:"language-C++ vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"C++"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"class"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," A"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"{")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    public:")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"        int"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," a;")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    public:")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"        int"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," getA"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"() "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"const"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"{")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"            return"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," a;")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        }")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"        int"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," getA"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(){")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"            return"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," a"),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"+"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"1"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},";")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        }")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"};")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"int"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," main"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(){")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    A a1;")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    const"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," A a2;")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    a1."),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"getA"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"();"),l("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"//调用的是普通的成员函数")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    a2."),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"getA"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"();"),l("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"//调用的是const修饰的函数")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])]),l("button",{class:"collapse"})])])],-1),M=l("h2",{id:"static修饰符",tabindex:"-1"},[l("code",null,"static"),s("修饰符 "),l("a",{class:"header-anchor",href:"#static修饰符","aria-label":'Permalink to "`static`修饰符"'},"​")],-1),S=l("p",null,"可以修饰成员变量、局部变量、全局变量、成员函数、普通函数。",-1),O=l("ul",null,[l("li",null,"修饰局部变量 生命周期为整个程序结束后销毁，存放到全局区，内存中只有一份，编译期间就初始化好了。"),l("li",null,"修饰全局变量 生命周期也是整个程序销毁为止，存储在全局区共享一份，编译器初始化。但是这个全局变量变为只能在声明该变量的文件访问到。"),l("li",null,[s("修饰成员变量 与前两个类似，但是对于类来说的话是属于类的，通过类名访问"),l("code",null,"className::A"),s("且只能在类外初始化。")]),l("li",null,[s("修饰成员函数 也是属于类，通过类名访问，初始化没有要求，在 "),l("code",null,"static"),s(" 函数内不能访问非"),l("code",null,"static"),s("方法。")]),l("li",null,"修饰普通函数 表明该函数只在定义该函数的类中可以使用，可以防止命名冲突。")],-1),N=l("h2",{id:"this指针",tabindex:"-1"},[l("code",null,"this"),s("指针 "),l("a",{class:"header-anchor",href:"#this指针","aria-label":'Permalink to "`this`指针"'},"​")],-1),H=l("p",null,[s("是非静态成员函数中的隐含参数其指向调用函数的那个对象，编译器会在这个函数被调用时将这个调用者的地址赋值给这个 "),l("code",null,"this"),s(" 指针。 "),l("code",null,"this"),s(" 会隐式使用。被 "),l("code",null,"const"),s(" 修饰的成员函数中 "),l("code",null,"this"),s(" 被修饰为 "),l("code",null,"const className* const this"),s("，即"),l("code",null,"this"),s("是一个右值，不能对其进行取址操作。")],-1),L=l("h2",{id:"哪种变量会有默认值",tabindex:"-1"},[s("哪种变量会有默认值 "),l("a",{class:"header-anchor",href:"#哪种变量会有默认值","aria-label":'Permalink to "哪种变量会有默认值"'},"​")],-1),V=l("p",null,"全局变量、全局静态变量、局部静态变量。由编译器在编译阶段执行赋值操作。",-1),J=l("h2",{id:"类型转换cast",tabindex:"-1"},[s("类型转换"),l("code",null,"CAST"),s(),l("a",{class:"header-anchor",href:"#类型转换cast","aria-label":'Permalink to "类型转换`CAST`"'},"​")],-1),U=l("ul",null,[l("li",null,"静态类型转换： 用于类型相似的对象之间的转换，如 int 转换为 float，不会在运行时进行型检查。"),l("li",null,"动态类型转换： 一般是基类的指针或引用转换为派生类的指针或引用，会在运行时进行类型查"),l("li",null,[s("常量转换： 用于将"),l("code",null,"const"),s("类型对象转换为非"),l("code",null,"const"),s("类型的对象，只能用于转换掉"),l("code",null,"const"),s("属性不能改变对象的类型，前提是被转换的对象原本是非常量。")]),l("li",null,"重新解释转换： 将一个数据类型解释为另一个数据类型的值。")],-1),Y=l("h2",{id:"智能指针",tabindex:"-1"},[s("智能指针 "),l("a",{class:"header-anchor",href:"#智能指针","aria-label":'Permalink to "智能指针"'},"​")],-1),z=l("p",null,"原理: 智能指针是一个类，用来存储指向动态分配内存的对象的指针，负责自动释放动态分配内存的对象，防止内存泄露。动态分配的资源交给一个类对象去管理，当类对象声明周期结束时自动调用析构函数释放资源。",-1),R=l("ul",null,[l("li",null,[l("code",null,"std::unique_ptr<T>"),s("类型： 独占资源所有权的指针即只允许智能指针存放指向该资源(对象)的指针，不支持普通拷贝和赋值操作，只能移动所有权，不能用在STL标准容器中。")]),l("li",null,[l("code",null,"std::shared_ptr<T>"),s("类型： 共享资源所有权的指针，通过引用计数器管理。多个智能指针可以指向相同对象，该对象和其相关资源会在最后一个引用被销毁时被释放，由最后一个智能指针执行。")]),l("li",null,[l("code",null,"std::weak_ptr<T>"),s(" 类型： 共享资源的观察者，需要和"),l("code",null,"std::shared_ptr"),s("一起使用，不影响资源的生命周期，创建不会使得关联资源的引用计数器+1，只是引用。通过配合"),l("code",null,"shared_ptr<T>"),s("使用可以解决循环引用问题造成的内存泄露。")])],-1),G=l("h2",{id:"struct与class的区别",tabindex:"-1"},[l("code",null,"struct"),s("与"),l("code",null,"class"),s("的区别 "),l("a",{class:"header-anchor",href:"#struct与class的区别","aria-label":'Permalink to "`struct`与`class`的区别"'},"​")],-1),I=l("p",null,[l("code",null,"struct"),s("可以看做是数据结构的实现体，而"),l("code",null,"class"),s("是对象的实现体，最本质的区别是默认的访问控制。默认的继承访问权限："),l("code",null,"struct"),s("是 "),l("code",null,"public"),s("、"),l("code",null,"class"),s("是"),l("code",null,"private"),s("的。默认的数据访问权限(成员变量访问权限)："),l("code",null,"struct"),s("是"),l("code",null,"public"),s("、"),l("code",null,"class"),s("是"),l("code",null,"private"),s("的。")],-1),K=l("h2",{id:"为什么拥有虚函数的父类其析构函数必须为虚析构函数",tabindex:"-1"},[s("为什么拥有虚函数的父类其析构函数必须为虚析构函数？ "),l("a",{class:"header-anchor",href:"#为什么拥有虚函数的父类其析构函数必须为虚析构函数","aria-label":'Permalink to "为什么拥有虚函数的父类其析构函数必须为虚析构函数？"'},"​")],-1),Q=l("p",null,[s("答：因为在一个父类指针指向子类对象的时候，当其析构函数不为虚函数时，使用"),l("code",null,"delete"),s("释放指针所指对象的内存资源的时候不会触发"),l("strong",null,"动态绑定"),s("，也就是说只会调用父类当中的析构函数从而会导致子类中的资源无法被释放造成"),l("strong",null,"内存泄露"),s("。如果在父类当中将析构函数定义为虚析构函数的话就会触发动态绑定，父类的虚指针就可以找到其子类当中的析构函数并先调用子类的析构函数，在子类的析构函数中会嵌套调用父类的析构函数，这样资源才能被正确释放。虚析构函数的作用也就为了能用一个父类的指针来删除其指向的派生类对象。")],-1),W=l("h2",{id:"引用",tabindex:"-1"},[s("引用 "),l("a",{class:"header-anchor",href:"#引用","aria-label":'Permalink to "引用"'},"​")],-1),X=l("p",null,[s("看做是变量的别名，与绑定的变量共享相同的内存地址。 本质：在C++内部实现是一个指针常量。例如："),l("code",null,"int* const ref = &a;"),s("，也说明了引用为什么被初始化之后就不能对其赋值了。")],-1),Z=l("h2",{id:"指针",tabindex:"-1"},[s("指针 "),l("a",{class:"header-anchor",href:"#指针","aria-label":'Permalink to "指针"'},"​")],-1),ll=l("p",null,[s("指针也是一种数据结构，在32操作系统中大小为4字节64位操作系统中为8字节(可利用"),l("code",null,"sizeof()"),s("函数求得)。可以通过指针间接访问内存，指针存放的是地址，通过 "),l("code",null,"*"),s(" 解引用操作符可以操作指针指向的内存。")],-1),sl=l("p",null,[s("空指针：指向内存空间编号为0的空间(内存空间从0开始编号，一般用十六进制数表示)。"),l("br"),s(" 野指针：指针变量指向未知/非法的内存空间。"),l("br"),s(" 空指针和野指针都不是我们申请的空间，不要访问。")],-1),il=l("h2",{id:"内存模型",tabindex:"-1"},[s("内存模型 "),l("a",{class:"header-anchor",href:"#内存模型","aria-label":'Permalink to "内存模型"'},"​")],-1),el=l("p",null,"有代码区、全局区、堆区、栈区，编译后未执行exe之前只有代码区和全局区。",-1),al=l("ul",null,[l("li",null,"代码区 存放函数体的二进制代码(CPU执行的指令)，由操作系统管理,是共享只读的。"),l("li",null,"全局区 全局区里面包含常量区。存放全局变量、静态变量、全局常量(静态常量在栈区)、字符串常量，程序结束后由操作系统释放相应数据内存。"),l("li",null,"栈区 存放函数的参数、局部变量等，由编译器自动分配释放。"),l("li",null,[s("堆区 存放"),l("code",null,"new"),s("出来(动态分配内存)的对象，由程序员分配释放，程序结束后操作系统会回收未被释放的空间。")])],-1),tl=l("p",null,[s("栈里面的内存由编译器管理，存放方法的局部变量、参数等。堆里面是存放动态开辟内存的对象，即使用"),l("code",null,"new"),s("实例化的对象，由程序员手动申请与释放。")],-1),nl=l("h2",{id:"预处理指令-ifdef、-endif",tabindex:"-1"},[s("预处理指令"),l("code",null,"#ifdef"),s("、"),l("code",null,"#endif"),s(),l("a",{class:"header-anchor",href:"#预处理指令-ifdef、-endif","aria-label":'Permalink to "预处理指令`#ifdef`、`#endif`"'},"​")],-1),hl=l("p",null,"预处理指令，用于条件编译，可以根据是否定义了某个宏来决定是否编译某段代码，一般在头文件中使用，可以防止重定义错误。即在多个.cpp文件中重复引用了该头文件导致多次编译头文件中的内容。",-1),rl=l("div",{style:{"max-height":"300px"},class:"language-C++ vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"C++"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"//myhead.h")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"#ifdef"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," _MYHEAD_")]),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"#define"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," _MYHEAD_")]),s(`
`),l("span",{class:"line"}),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"class"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," A"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"{")]),s(`
`),l("span",{class:"line"}),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"};")]),s(`
`),l("span",{class:"line"}),s(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"#endif")])])]),l("button",{class:"collapse"})],-1),dl=l("h1",{id:"stl容器",tabindex:"-1"},[s("STL容器 "),l("a",{class:"header-anchor",href:"#stl容器","aria-label":'Permalink to "STL容器"'},"​")],-1),ol=l("p",null,"分为：",-1),cl=l("ul",null,[l("li",null,[s("序列式容器(元素可序但未必有序，允许双向遍历) "),l("ul",null,[l("li",null,"vector(动态数组)"),l("li",null,"deque(双端队列)"),l("li",null,"list(双向链表)")])]),l("li",null,"无序容器。"),l("li",null,[s("关联式容器(存储键值对，通过键来组织元素) "),l("ul",null,[l("li",null,"set(不允许重复元素，只有键)"),l("li",null,"multiset(多重集合，允许多个元素具有相同的键)"),l("li",null,"map(映射，一个键映射一个值)"),l("li",null,"multimap(多重映射，允许多个键映射到相同的值)")])])],-1),kl=l("h2",{id:"array",tabindex:"-1"},[s("array "),l("a",{class:"header-anchor",href:"#array","aria-label":'Permalink to "array"'},"​")],-1),ul=l("p",null,"固定大小的顺序容器。",-1),pl=l("h2",{id:"vector",tabindex:"-1"},[s("vector "),l("a",{class:"header-anchor",href:"#vector","aria-label":'Permalink to "vector"'},"​")],-1),_l=l("p",null,[s("可变大小的数组序列容器。"),l("br"),s(" 自动扩容原理：申请空间、拷贝元素、释放空间。windows下是1.5倍，linux下是2倍。太大会浪费空间，太小会频繁扩容，2倍不能利用前面释放的内存空间而1.5倍经过多次扩容后可以利用前面释放的内存空间。")],-1),gl=l("h2",{id:"deque",tabindex:"-1"},[s("deque "),l("a",{class:"header-anchor",href:"#deque","aria-label":'Permalink to "deque"'},"​")],-1),ml=l("p",null,"双端队列，是一个具有动态大小的序列容器，可以在两端扩展或收缩。",-1),El=l("h2",{id:"forward-list",tabindex:"-1"},[s("forward_list "),l("a",{class:"header-anchor",href:"#forward-list","aria-label":'Permalink to "forward_list"'},"​")],-1),fl=l("p",null,"单向链表，是序列容器。",-1),yl=l("h2",{id:"list",tabindex:"-1"},[s("list "),l("a",{class:"header-anchor",href:"#list","aria-label":'Permalink to "list"'},"​")],-1),bl=l("p",null,"双向链表，是序列容器。",-1),vl=l("h2",{id:"set",tabindex:"-1"},[s("set "),l("a",{class:"header-anchor",href:"#set","aria-label":'Permalink to "set"'},"​")],-1),Fl=l("p",null,"红黑树实现，按照特定顺序存储唯一元素的容器，是一种特殊的map只有键没有值。",-1),Al=l("h2",{id:"unordered-set",tabindex:"-1"},[s("unordered_set "),l("a",{class:"header-anchor",href:"#unordered-set","aria-label":'Permalink to "unordered_set"'},"​")],-1),Cl=l("p",null,"通过哈希表计算元素位置，类似unordered_map，只有键没有值。",-1),xl=l("h2",{id:"map-类似java中的treemap",tabindex:"-1"},[s("map (类似java中的TreeMap) "),l("a",{class:"header-anchor",href:"#map-类似java中的treemap","aria-label":'Permalink to "map (类似java中的TreeMap)"'},"​")],-1),Pl=l("ul",null,[l("li",null,"关联容器，按照一定顺序存储由key和value组合成的元素。"),l("li",null,"由红黑树实现，使用于有序数据的场景")],-1),Dl=l("h2",{id:"unordered-map-类似java中的hashmap",tabindex:"-1"},[s("unordered_map (类似java中的HashMap) "),l("a",{class:"header-anchor",href:"#unordered-map-类似java中的hashmap","aria-label":'Permalink to "unordered_map (类似java中的HashMap)"'},"​")],-1),Bl=l("ul",null,[l("li",null,"与map类似，但由哈希表实现(无序)，查找效率高适用于需要高效查找的场景。")],-1),Tl=l("h1",{id:"排序算法",tabindex:"-1"},[s("排序算法 "),l("a",{class:"header-anchor",href:"#排序算法","aria-label":'Permalink to "排序算法"'},"​")],-1),jl=l("h1",{id:"待完成",tabindex:"-1"},[s("待完成 "),l("a",{class:"header-anchor",href:"#待完成","aria-label":'Permalink to "待完成"'},"​")],-1),wl=l("ul",{class:"contains-task-list"},[l("li",{class:"task-list-item"},[l("input",{class:"task-list-item-checkbox",checked:"",disabled:"",type:"checkbox"}),s(" STL容器")]),l("li",{class:"task-list-item"},[l("input",{class:"task-list-item-checkbox",checked:"",disabled:"",type:"checkbox"}),s(" C++防止重复包含 ifdefine endif 关键字")]),l("li",null,"[] 设计模式"),l("li",null,"[] 排序算法"),l("li",null,"[] cocos内存管理"),l("li",null,"[] cocos渲染机制")],-1),Jl={__name:"c-plus",setup($l,{expose:d}){const t=JSON.parse('{"title":"C++","description":"","frontmatter":{"title":"C++","date":"2024-5-8","categories":"C++","tags":["C++"],"top":0},"headers":[{"level":2,"title":"面向对象(OOP)的特性","slug":"面向对象-oop-的特性","link":"#面向对象-oop-的特性","children":[]},{"level":2,"title":"虚函数","slug":"虚函数","link":"#虚函数","children":[]},{"level":2,"title":"虚指针","slug":"虚指针","link":"#虚指针","children":[]},{"level":2,"title":"纯虚函数","slug":"纯虚函数","link":"#纯虚函数","children":[]},{"level":2,"title":"内联函数 inline","slug":"内联函数-inline","link":"#内联函数-inline","children":[]},{"level":2,"title":"析构函数","slug":"析构函数","link":"#析构函数","children":[]},{"level":2,"title":"拷贝构造函数(浅拷贝)","slug":"拷贝构造函数-浅拷贝","link":"#拷贝构造函数-浅拷贝","children":[]},{"level":2,"title":"const修饰符","slug":"const修饰符","link":"#const修饰符","children":[]},{"level":2,"title":"static修饰符","slug":"static修饰符","link":"#static修饰符","children":[]},{"level":2,"title":"this指针","slug":"this指针","link":"#this指针","children":[]},{"level":2,"title":"哪种变量会有默认值","slug":"哪种变量会有默认值","link":"#哪种变量会有默认值","children":[]},{"level":2,"title":"类型转换CAST","slug":"类型转换cast","link":"#类型转换cast","children":[]},{"level":2,"title":"智能指针","slug":"智能指针","link":"#智能指针","children":[]},{"level":2,"title":"struct与class的区别","slug":"struct与class的区别","link":"#struct与class的区别","children":[]},{"level":2,"title":"为什么拥有虚函数的父类其析构函数必须为虚析构函数？","slug":"为什么拥有虚函数的父类其析构函数必须为虚析构函数","link":"#为什么拥有虚函数的父类其析构函数必须为虚析构函数","children":[]},{"level":2,"title":"引用","slug":"引用","link":"#引用","children":[]},{"level":2,"title":"指针","slug":"指针","link":"#指针","children":[]},{"level":2,"title":"内存模型","slug":"内存模型","link":"#内存模型","children":[]},{"level":2,"title":"预处理指令#ifdef、#endif","slug":"预处理指令-ifdef、-endif","link":"#预处理指令-ifdef、-endif","children":[]},{"level":2,"title":"array","slug":"array","link":"#array","children":[]},{"level":2,"title":"vector","slug":"vector","link":"#vector","children":[]},{"level":2,"title":"deque","slug":"deque","link":"#deque","children":[]},{"level":2,"title":"forward_list","slug":"forward-list","link":"#forward-list","children":[]},{"level":2,"title":"list","slug":"list","link":"#list","children":[]},{"level":2,"title":"set","slug":"set","link":"#set","children":[]},{"level":2,"title":"unordered_set","slug":"unordered-set","link":"#unordered-set","children":[]},{"level":2,"title":"map (类似java中的TreeMap)","slug":"map-类似java中的treemap","link":"#map-类似java中的treemap","children":[]},{"level":2,"title":"unordered_map (类似java中的HashMap)","slug":"unordered-map-类似java中的hashmap","link":"#unordered-map-类似java中的hashmap","children":[]}],"relativePath":"pages/posts/notes/c-plus.md","path":"/home/runner/work/blog-code/blog-code/pages/posts/notes/c-plus.md","lastUpdated":1715396064000}'),h=k(),n=t.frontmatter||{};return h.meta.frontmatter=Object.assign(h.meta.frontmatter||{},t.frontmatter||{}),r("pageData",t),r("valaxy:frontmatter",n),globalThis.$frontmatter=n,d({frontmatter:{title:"C++",date:"2024-5-8",categories:"C++",tags:["C++"],top:0}}),(e,Ml)=>{const o=c;return u(),p(o,{frontmatter:_(n)},{"main-content-md":i(()=>[g,m,E,f,y,b,v,F,A,C,x,P,D,B,T,j,w,$,q,M,S,O,N,H,L,V,J,U,Y,z,R,G,I,K,Q,W,X,Z,ll,sl,il,el,al,tl,nl,hl,rl,dl,ol,cl,kl,ul,pl,_l,gl,ml,El,fl,yl,bl,vl,Fl,Al,Cl,xl,Pl,Dl,Bl,Tl,jl,wl]),"main-header":i(()=>[a(e.$slots,"main-header")]),"main-header-after":i(()=>[a(e.$slots,"main-header-after")]),"main-nav":i(()=>[a(e.$slots,"main-nav")]),"main-content":i(()=>[a(e.$slots,"main-content")]),"main-content-after":i(()=>[a(e.$slots,"main-content-after")]),"main-nav-before":i(()=>[a(e.$slots,"main-nav-before")]),"main-nav-after":i(()=>[a(e.$slots,"main-nav-after")]),comment:i(()=>[a(e.$slots,"comment")]),footer:i(()=>[a(e.$slots,"footer")]),aside:i(()=>[a(e.$slots,"aside")]),"aside-custom":i(()=>[a(e.$slots,"aside-custom")]),default:i(()=>[a(e.$slots,"default")]),_:3},8,["frontmatter"])}}};export{Jl as default};
