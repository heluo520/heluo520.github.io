import{_ as k}from"./ValaxyMain.vue_vue_type_style_index_0_lang-C-4bwT3N.js";import{a as c,p as r,o as p,c as u,w as l,f as E,g as m,r as e,h as a,i}from"./app-D8Fg0Whz.js";import"./YunFooter.vue_vue_type_script_setup_true_lang-uKVcHcze.js";import"./YunCard.vue_vue_type_script_setup_true_lang-CX691jYT.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-DWniK4MT.js";import"./index-C7yU5XnD.js";const g=a("p",null,"有关java的一些零散知识点。",-1),_=a("h1",{id:"java基础",tabindex:"-1"},[i("java基础 "),a("a",{class:"header-anchor",href:"#java基础","aria-label":'Permalink to "java基础"'},"​")],-1),y=a("h2",{id:"comparable与comparator两个接口的区别",tabindex:"-1"},[i("Comparable与Comparator两个接口的区别 "),a("a",{class:"header-anchor",href:"#comparable与comparator两个接口的区别","aria-label":'Permalink to "Comparable与Comparator两个接口的区别"'},"​")],-1),v=a("p",null,"Comparable(java.lang)接口：实现此接口只能定义一种排序规则，通过实现接口中的int compareTo(T o)方法来比较，需要待排序类自己实现。",-1),b=a("p",null,"Comparator(java.util)接口：使用此接口待比较对象不需要自己实现，即可以保持待比较类的原样实现比较功能。实现此接口的类即为比较器，可以在此类中的compare方法中定义比较规则，通过多个比较器可以实现按照不同属性进行排序的功能。",-1),f=a("h2",{id:"equals-与hashcode",tabindex:"-1"},[i("equals()与hashCode() "),a("a",{class:"header-anchor",href:"#equals-与hashcode","aria-label":'Permalink to "equals()与hashCode()"'},"​")],-1),A=a("p",null,'"="比较的为地址，equals()比较两个对象是否等价(值是否相等)。重写了equals()方法一定要重写hashCode()方法，等价的两个对象hashCode一定相等但是hashCode相等的两个对象不一定等价，hashCode的计算具有随机性导致。HashMap(key使用)与HashSet是使用hashCode来计算对象的存储位置，所以当重写了equals而不重写hashCode方法会导致在集合中添加相同的元素。',-1),C=a("h2",{id:"浅拷贝与深拷贝",tabindex:"-1"},[i("浅拷贝与深拷贝 "),a("a",{class:"header-anchor",href:"#浅拷贝与深拷贝","aria-label":'Permalink to "浅拷贝与深拷贝"'},"​")],-1),j=a("p",null,"浅拷贝：拷贝对象与原始对象的引用(地址)是相同的，拷贝的是引用。 深拷贝：拷贝对象与原始对象的引用不同，拷贝的是值。",-1),F=a("p",null,"Object中的clone()方法为浅拷贝。使用此法需要实现Cloneable接口，既复杂又有风险，还需要进行类型转换不推荐使用此方法进行拷贝。可以使用对象拷贝工厂或拷贝构造函数来进行拷贝一个对象。例如",-1),J=a("div",{style:{"max-height":"300px"},class:"language-java vp-adaptive-theme"},[a("button",{title:"Copy Code",class:"copy"}),a("span",{class:"lang"},"java"),a("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[a("code",{"v-pre":""},[a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"public"),a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," class"),a("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," A"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"{")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    public"),a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," int"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," age;")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ...")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"    //拷贝构造函数")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    public"),a("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," A"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(A "),a("span",{style:{"--shiki-light":"#E36209","--shiki-dark":"#FFAB70"}},"a"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"){")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"        this"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},".age "),a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," a.age;")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        ...")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])]),a("button",{class:"collapse"})],-1),D=a("h2",{id:"接口与抽象类",tabindex:"-1"},[i("接口与抽象类 "),a("a",{class:"header-anchor",href:"#接口与抽象类","aria-label":'Permalink to "接口与抽象类"'},"​")],-1),x=a("ul",null,[a("li",null,"接口：方法和字段默认都是public(只能为此)，且字段默认都是是static final修饰。java8开始接口中的方法可以有默认实现，java9开始方法可以被private修饰(这样就可以定义一些私密的复用代码，即只在本接口中使用的)。"),a("li",null,"抽象类：访问修饰符没有限制，只能被继承不能实例化。"),a("li",null,[i("使用时机： "),a("ul",null,[a("li",null,"接口：需要让不相关的类都实现同一个方法、需要使用多重继承。"),a("li",null,"抽象类：需要让相关的类中共享代码、需要控制方法的访问权限、需要继承非静态字段与非常量字段。")])])],-1),M=a("h2",{id:"重写与重载",tabindex:"-1"},[i("重写与重载 "),a("a",{class:"header-anchor",href:"#重写与重载","aria-label":'Permalink to "重写与重载"'},"​")],-1),P=a("ul",null,[a("li",null,"重写：外壳不变，核心改变(返回值类型需为父类方法中的返回值类型或其子类，异常与访问权限也是如此，即只能小不能扩大范围)。"),a("li",null,"重载：方法名相同，但参数列表要唯一(即参数类型、个数、顺序至少有一个不同)。")],-1),V=a("h2",{id:"泛型",tabindex:"-1"},[i("泛型 "),a("a",{class:"header-anchor",href:"#泛型","aria-label":'Permalink to "泛型"'},"​")],-1),B=a("p",null,"泛型是一种特殊的类型，即在创建对象或调用方法时才会明确其具体的类型。主要使用有泛型类、泛型接口、泛型方法。静态方法访问不到类上的泛型声明，需要自己声明(即定义为一个泛型方法)。",-1),T=a("div",{style:{"max-height":"300px"},class:"language-java vp-adaptive-theme"},[a("button",{title:"Copy Code",class:"copy"}),a("span",{class:"lang"},"java"),a("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[a("code",{"v-pre":""},[a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"/* 泛型类的声明 */")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"public"),a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," class"),a("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," Ciallo"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"T"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},">{")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    public"),a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," static"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"T"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"> "),a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"void"),a("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," A"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(T "),a("span",{style:{"--shiki-light":"#E36209","--shiki-dark":"#FFAB70"}},"a"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"){")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"        //这个类型T的实际类型可以与类上声明的T类型相同也可不同")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        System.out."),a("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"println"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(a);")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    } ")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    public"),a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," void"),a("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," B"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(T "),a("span",{style:{"--shiki-light":"#E36209","--shiki-dark":"#FFAB70"}},"b"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"){")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"        //这个T类型必须和类上声明的T类型一致")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        System.out."),a("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"println"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(b);")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"    //泛型方法的声明")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    public"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," <"),a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"T"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"> "),a("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"void"),a("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," C"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(T "),a("span",{style:{"--shiki-light":"#E36209","--shiki-dark":"#FFAB70"}},"c"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"){")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"        //这个T是一个新的类型T，即可以与类上的T类型相同也可不同")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        System.out."),a("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"println"),a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(c);")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),i(`
`),a("span",{class:"line"},[a("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])]),a("button",{class:"collapse"})],-1),L=a("h2",{id:"部分内容参考自",tabindex:"-1"},[i("部分内容参考自 "),a("a",{class:"header-anchor",href:"#部分内容参考自","aria-label":'Permalink to "部分内容参考自"'},"​")],-1),q=a("blockquote",null,[a("p",null,[a("a",{href:"https://www.cyc2018.xyz/Java/Java%20%E5%9F%BA%E7%A1%80.html",target:"_blank",rel:"noreferrer"},"java基础")])],-1),w=a("h1",{id:"java容器",tabindex:"-1"},[i("java容器 "),a("a",{class:"header-anchor",href:"#java容器","aria-label":'Permalink to "java容器"'},"​")],-1),$=a("h2",{id:"分为两大类collection与map。",tabindex:"-1"},[i("分为两大类Collection与Map。 "),a("a",{class:"header-anchor",href:"#分为两大类collection与map。","aria-label":'Permalink to "分为两大类Collection与Map。"'},"​")],-1),R=a("p",null,"Collection：",-1),S=a("ul",null,[a("li",null,[i("Set: "),a("ul",null,[a("li",null,"TreeSet：基于红黑树实现，支持有序性操作。"),a("li",null,"HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去元素的插入顺序信息。"),a("li",null,"LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元的插入顺序。")])]),a("li",null,[i("List: "),a("ul",null,[a("li",null,"ArrayList：基于动态数组实现，支持随机访问。"),a("li",null,"Vector：和 ArrayList 类似，但它是线程安全的。"),a("li",null,"LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。")])]),a("li",null,[i("Queue: "),a("ul",null,[a("li",null,"LinkedList：可以用它来实现双向队列。"),a("li",null,"PriorityQueue：基于堆结构实现，可以用它来实现优先队列。")])])],-1),H=a("p",null,"Map:",-1),N=a("ul",null,[a("li",null,"TreeMap：基于红黑树实现。"),a("li",null,"HashMap：基于哈希表实现。"),a("li",null,"HashTable：和 HashMap 类似，但它是线程安全的，它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全。")],-1),U=a("h2",{id:"源码学习",tabindex:"-1"},[i("源码学习 "),a("a",{class:"header-anchor",href:"#源码学习","aria-label":'Permalink to "源码学习"'},"​")],-1),K=a("p",null,"ArrayList的扩容：默认数组大小为10(实际是0，只有添加了第一个元素才会生成一个大小为10的数组)，扩容后的大小=老的容量大小+老的容量大小>>1，即扩容后为原来的1.5倍，>>1需要取整(偶数时扩容为1.5倍)。",-1),z=a("h2",{id:"部分内容参考自-1",tabindex:"-1"},[i("部分内容参考自 "),a("a",{class:"header-anchor",href:"#部分内容参考自-1","aria-label":'Permalink to "部分内容参考自"'},"​")],-1),O=a("blockquote",null,[a("p",null,[a("a",{href:"https://www.cyc2018.xyz/Java/Java%20%E5%AE%B9%E5%99%A8.html",target:"_blank",rel:"noreferrer"},"java容器")])],-1),W=a("h1",{id:"jvm",tabindex:"-1"},[i("JVM "),a("a",{class:"header-anchor",href:"#jvm","aria-label":'Permalink to "JVM"'},"​")],-1),Q=a("h2",{id:"jdk与jre",tabindex:"-1"},[i("JDK与JRE "),a("a",{class:"header-anchor",href:"#jdk与jre","aria-label":'Permalink to "JDK与JRE"'},"​")],-1),X=a("ul",null,[a("li",null,"JDK(Java Development Kit) Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等(JRE+java开发辅助工具)。"),a("li",null,"JRE(Java Runtime Environment) Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库(JVM+java程序运行时所需要的类库)。")],-1),Y=a("h2",{id:"jvm的总体机制",tabindex:"-1"},[i("JVM的总体机制 "),a("a",{class:"header-anchor",href:"#jvm的总体机制","aria-label":'Permalink to "JVM的总体机制"'},"​")],-1),G=a("p",null,"JAVA 源程序编译运行过程：java 源程序->编译->.class字节码文件->类加载到 JVM 上运行。",-1),I=a("p",null,"JVM 的总体运行机制：",-1),Z=a("ul",null,[a("li",null,"使用类加载器加载 .class 字节码文件到 JVM 内存中的方法区。"),a("li",null,"在 JVM 的内存中存储相关数据(类的信息、静态变量、常量)。"),a("li",null,"在执行引擎中将 .class 翻译为 CPU 能够执行的指令。"),a("li",null,[i("将指令发送给 CPU 执行 "),a("img",{src:"https://secure2.wostatic.cn/static/gF4Uc1UqkjWtzXaMxxPRBz/image.png?auth_key=1714807929-aPERoUyYZt8w4DvHXf1Wv2-0-b805b86a24759a32e9e978987c188e27&file_size=133374",alt:"JVM运行机制"})])],-1),aa=a("h2",{id:"类加载机制",tabindex:"-1"},[i("类加载机制 "),a("a",{class:"header-anchor",href:"#类加载机制","aria-label":'Permalink to "类加载机制"'},"​")],-1),ia=a("ul",null,[a("li",null,"类加载器子系统负责从文件系统或网络中加载.class字节码文件。"),a("li",null,"CLassLoader 只负责字节码文件的加载，由执行引擎来判断此字节码文件是否可以运行。"),a("li",null,"JVM中有四中类加载器(前三中为JVM自带)：启动类加载器Bootstrap(爷爷)、扩展类加载器Extension(爸爸)、应用类加载器AppClassLoader(儿子)、用户自定义加载器(程序员自己开发一个继承 java.lang.ClassLoader 的类来定制类加载方式)。其中启动类加载器由C++编写，不是 ClassLoader 的子类，在 java 中打印时为 null。"),a("li",null,"父子关系(逻辑上)：通过parent属性维护。"),a("li",null,"加载顺序(双亲委派机制)：先获取要加载的类所对应范围的类加载器，此加载器不会立即查找而是会将任务上移交给其上一级加载器，一直到顶级的应用类加载器，然后从应用类加载器开始查找，找到就加载并到此为止，否则抛出 ClassNotFoundException。"),a("li",null,[i("双亲委派机制的好处： "),a("ul",null,[a("li",null,"防止重复加载类，保证了JVM范围内类的全限定名是类的唯一标识。"),a("li",null,"安全机制，防止恶意替换JRE定义的核心API(沙箱安全机制)。")])])],-1),la=a("h2",{id:"jvm内存",tabindex:"-1"},[i("JVM内存 "),a("a",{class:"header-anchor",href:"#jvm内存","aria-label":'Permalink to "JVM内存"'},"​")],-1),sa=a("h4",{id:"线程私有",tabindex:"-1"},[i("线程私有 "),a("a",{class:"header-anchor",href:"#线程私有","aria-label":'Permalink to "线程私有"'},"​")],-1),ea=a("ul",null,[a("li",null,"程序计数器： 记录正在执行的虚拟机字节码指令地址(就是记录指令地址)，执行的是本地方法则为NULL。"),a("li",null,"JAVA虚拟机栈： 由一个个栈帧组成，栈帧中存储有 局部变量表、操作数栈、常量池应用等信息。"),a("li",null,"本地方法栈：")],-1),ta=a("h4",{id:"线程共有",tabindex:"-1"},[i("线程共有 "),a("a",{class:"header-anchor",href:"#线程共有","aria-label":'Permalink to "线程共有"'},"​")],-1),na=a("h2",{id:"参考文献",tabindex:"-1"},[i("参考文献 "),a("a",{class:"header-anchor",href:"#参考文献","aria-label":'Permalink to "参考文献"'},"​")],-1),ha=a("blockquote",null,[a("p",null,[a("a",{href:"https://www.wolai.com/35WiNGjxM8qcDAA4EchY4T",target:"_blank",rel:"noreferrer"},"JVM1.6")])],-1),ra=a("h1",{id:"待定",tabindex:"-1"},[i("待定… "),a("a",{class:"header-anchor",href:"#待定","aria-label":'Permalink to "待定..."'},"​")],-1),oa=a("h1",{id:"其它",tabindex:"-1"},[i("其它 "),a("a",{class:"header-anchor",href:"#其它","aria-label":'Permalink to "其它"'},"​")],-1),da=a("p",null,"在保证x是2的n次方的时候y%x的结果与y&(x-1)的结果是一样的。",-1),va={__name:"碎片",setup(ka,{expose:o}){const t=JSON.parse('{"title":"碎片小知识","description":"","frontmatter":{"title":"碎片小知识","date":"2024-4-7","update":"2024-4-7","hide":"index","categories":"笔记","tags":["小知识"]},"headers":[{"level":2,"title":"Comparable与Comparator两个接口的区别","slug":"comparable与comparator两个接口的区别","link":"#comparable与comparator两个接口的区别","children":[]},{"level":2,"title":"equals()与hashCode()","slug":"equals-与hashcode","link":"#equals-与hashcode","children":[]},{"level":2,"title":"浅拷贝与深拷贝","slug":"浅拷贝与深拷贝","link":"#浅拷贝与深拷贝","children":[]},{"level":2,"title":"接口与抽象类","slug":"接口与抽象类","link":"#接口与抽象类","children":[]},{"level":2,"title":"重写与重载","slug":"重写与重载","link":"#重写与重载","children":[]},{"level":2,"title":"泛型","slug":"泛型","link":"#泛型","children":[]},{"level":2,"title":"部分内容参考自","slug":"部分内容参考自","link":"#部分内容参考自","children":[]},{"level":2,"title":"分为两大类Collection与Map。","slug":"分为两大类collection与map。","link":"#分为两大类collection与map。","children":[]},{"level":2,"title":"源码学习","slug":"源码学习","link":"#源码学习","children":[]},{"level":2,"title":"部分内容参考自","slug":"部分内容参考自-1","link":"#部分内容参考自-1","children":[]},{"level":2,"title":"JDK与JRE","slug":"jdk与jre","link":"#jdk与jre","children":[]},{"level":2,"title":"JVM的总体机制","slug":"jvm的总体机制","link":"#jvm的总体机制","children":[]},{"level":2,"title":"类加载机制","slug":"类加载机制","link":"#类加载机制","children":[]},{"level":2,"title":"JVM内存","slug":"jvm内存","link":"#jvm内存","children":[]},{"level":2,"title":"参考文献","slug":"参考文献","link":"#参考文献","children":[]}],"relativePath":"pages/posts/javaee/碎片.md","path":"/home/runner/work/blog-code/blog-code/pages/posts/javaee/碎片.md","lastUpdated":1715521896000}'),h=c(),n=t.frontmatter||{};return h.meta.frontmatter=Object.assign(h.meta.frontmatter||{},t.frontmatter||{}),r("pageData",t),r("valaxy:frontmatter",n),globalThis.$frontmatter=n,o({frontmatter:{title:"碎片小知识",date:"2024-4-7",update:"2024-4-7",hide:"index",categories:"笔记",tags:["小知识"]}}),(s,pa)=>{const d=k;return p(),u(d,{frontmatter:E(n)},{"main-content-md":l(()=>[g,m(" more "),_,y,v,b,f,A,C,j,F,J,D,x,M,P,V,B,T,L,q,w,$,R,S,H,N,U,K,z,O,W,Q,X,Y,G,I,Z,aa,ia,la,sa,ea,ta,na,ha,ra,oa,da]),"main-header":l(()=>[e(s.$slots,"main-header")]),"main-header-after":l(()=>[e(s.$slots,"main-header-after")]),"main-nav":l(()=>[e(s.$slots,"main-nav")]),"main-content":l(()=>[e(s.$slots,"main-content")]),"main-content-after":l(()=>[e(s.$slots,"main-content-after")]),"main-nav-before":l(()=>[e(s.$slots,"main-nav-before")]),"main-nav-after":l(()=>[e(s.$slots,"main-nav-after")]),comment:l(()=>[e(s.$slots,"comment")]),footer:l(()=>[e(s.$slots,"footer")]),aside:l(()=>[e(s.$slots,"aside")]),"aside-custom":l(()=>[e(s.$slots,"aside-custom")]),default:l(()=>[e(s.$slots,"default")]),_:3},8,["frontmatter"])}}};export{va as default};
